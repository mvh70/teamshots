generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                   String               @id @default(cuid())
  email                String               @unique
  password             String?
  emailVerified        DateTime?
  locale               String               @default("en")
  signupDomain         String?              // Domain user signed up from (e.g., "teamshotspro.com", "photoshotspro.com")
  subscriptionStatus   String?
  stripeCustomerId     String?              @unique
  stripeSubscriptionId String?              @unique
  createdAt            DateTime             @default(now())
  updatedAt            DateTime             @updatedAt
  role                 String               @default("user")
  metadata             Json                 @default("{}")
  isAdmin              Boolean              @default(false)
  freeTrialGrantedAt   DateTime?
  planPeriod           String?
  planTier             String?
  tokenVersion          Int                  @default(0) // Incremented when role/permissions change to invalidate all sessions
  accounts             Account[]
  teams                Team[]               @relation("TeamAdmin")
  creditTransactions   CreditTransaction[]
  person               Person?
  refreshTokens        RefreshToken[]
  sessions             Session[]
  convertedFromInvite  TeamInvite?
  transactions         Transaction[]
  subscriptionChanges  SubscriptionChange[]
  userPackages         UserPackage[]
  revokedTokens        RevokedToken[]
  contexts             Context[]

  @@index([email])
}

model Person {
  id                 String              @id @default(cuid())
  firstName          String
  lastName           String?
  email              String?
  userId             String?             @unique
  teamId             String?
  inviteToken        String?             @unique
  invitedAt          DateTime?
  inviteAcceptedAt   DateTime?
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  onboardingState    String?             @default("not_started") // "not_started", "in_progress", "completed"
  creditTransactions CreditTransaction[]
  generations        Generation[]
  team               Team?               @relation(fields: [teamId], references: [id])
  user               User?               @relation(fields: [userId], references: [id], onDelete: Cascade)
  selfies            Selfie[]
  teamInvite         TeamInvite?
  feedback           Feedback[]

  @@index([email])
  @@index([teamId])
  @@index([inviteToken])
  @@index([userId])
}

model Team {
  id                   String               @id @default(cuid())
  name                 String
  website              String?
  domain               String?
  adminId              String
  subscriptionStatus   String?
  stripeCustomerId     String?              @unique
  stripeSubscriptionId String?              @unique
  createdAt            DateTime             @default(now())
  updatedAt            DateTime             @updatedAt
  activeContextId      String?              @unique
  activeContext        Context?             @relation("ActiveContext", fields: [activeContextId], references: [id])
  admin                User                 @relation("TeamAdmin", fields: [adminId], references: [id], onDelete: Cascade)
  contexts             Context[]
  creditTransactions   CreditTransaction[]
  teamMembers          Person[]
  teamInvites          TeamInvite[]
  subscriptionChanges  SubscriptionChange[]

  @@index([adminId])
  @@index([domain])
}

model Context {
  id               String       @id @default(cuid())
  name             String
  teamId           String?
  userId           String?
  packageName      String       @default("headshot1")
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt
  settings         Json         @default("{}")
  activeForTeam    Team?        @relation("ActiveContext")
  team             Team?        @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user             User?        @relation(fields: [userId], references: [id], onDelete: Cascade)
  generations      Generation[]
  teamInvites      TeamInvite[]

  @@index([teamId])
  @@index([userId])
  @@index([packageName])
}

model Generation {
  id                     String    @id @default(cuid())
  creditsUsed            Int       @default(4)
  actualCost             Float?
  provider               String    @default("gemini")
  status                 String    @default("processing")
  errorMessage           String?
  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @updatedAt
  acceptedAt             DateTime?
  acceptedPhotoKey       String?
  completedAt            DateTime?
  contextId              String?
  generatedPhotoKeys     String[]
  personId               String
  uploadedPhotoKey       String
  adminApproved          Boolean   @default(false)
  moderationDate         DateTime?
  moderationPassed       Boolean   @default(false)
  moderationScore        Float?
  userApproved           Boolean   @default(false)
  creditSource           String    @default("individual")
  deleted                Boolean   @default(false)
  deletedAt              DateTime?
  isPublic               Boolean   @default(false)
  maxRegenerations       Int       @default(2)
  remainingRegenerations Int       @default(2)
  selfieId               String?
  generationGroupId      String?
  groupIndex             Int?
  isOriginal             Boolean   @default(true)
  styleSettings          Json?
  context                Context?  @relation(fields: [contextId], references: [id])
  person                 Person    @relation(fields: [personId], references: [id], onDelete: Cascade)
  selfie                 Selfie?   @relation(fields: [selfieId], references: [id])
  feedback               Feedback[]

  @@index([personId])
  @@index([contextId])
  @@index([selfieId])
  @@index([status])
  @@index([createdAt])
  @@index([isPublic])
  @@index([personId, createdAt])
}

model Selfie {
  id                 String       @id @default(cuid())
  personId           String
  key                String
  validated          Boolean      @default(false)
  usedInGenerationId String?
  selected           Boolean      @default(false)
  createdAt          DateTime     @default(now())
  fitnessApproved    Boolean      @default(false)
  moderationDate     DateTime?
  moderationPassed   Boolean      @default(false)
  moderationScore    Float?
  userApproved       Boolean      @default(false)
  isPublic           Boolean      @default(false)
  processedKey       String?
  uploadedByUser     String?
  uploadedViaToken   String?
  generations        Generation[]
  person             Person       @relation(fields: [personId], references: [id], onDelete: Cascade)

  @@index([personId])
  @@index([uploadedViaToken])
  @@index([createdAt])
  @@index([isPublic])
  @@index([personId, createdAt])
  @@index([selected])
}

model Transaction {
  id              String   @id @default(cuid())
  userId          String
  type            String
  amount          Float
  creditsDelta    Int
  stripePaymentId String?
  stripeInvoiceId String?
  description     String?
  createdAt       DateTime @default(now())
  creditSource    String?
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([type])
  @@index([createdAt])
}

model WaitlistSignup {
  id        String   @id @default(cuid())
  email     String   @unique
  notified  Boolean  @default(false)
  source    String?
  createdAt DateTime @default(now())

  @@index([email])
  @@index([notified])
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model OTP {
  id        String   @id @default(cuid())
  email     String
  code      String
  expires   DateTime
  verified  Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([email])
  @@index([code])
  @@index([expires])
}

model CreditTransaction {
  id                   String              @id @default(cuid())
  teamId               String?
  personId             String?
  userId               String?
  amount               Float?
  type                 String
  description          String?
  relatedTransactionId String?
  teamInviteId         String?
  createdAt            DateTime            @default(now())
  credits              Int
  currency             String?             @default("USD")
  metadata             Json                @default("{}")
  planPeriod           String?
  planTier             String?
  stripeInvoiceId      String?
  stripePaymentId      String?
  stripeSubscriptionId String?
  team                 Team?               @relation(fields: [teamId], references: [id], onDelete: Cascade)
  person               Person?             @relation(fields: [personId], references: [id], onDelete: Cascade)
  relatedTransaction   CreditTransaction?  @relation("TransferPair", fields: [relatedTransactionId], references: [id])
  reverseTransactions  CreditTransaction[] @relation("TransferPair")
  teamInvite           TeamInvite?         @relation(fields: [teamInviteId], references: [id])
  user                 User?               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([teamId])
  @@index([personId])
  @@index([userId])
  @@index([type])
  @@index([createdAt])
  @@index([stripePaymentId])
  @@index([stripeSubscriptionId])
  @@index([planTier])
}

model AppSetting {
  key   String @id
  value String
}

model SubscriptionChange {
  id                   String   @id @default(cuid())
  userId               String
  teamId               String?
  planTier             String // 'individual' | 'pro'
  planPeriod           String // 'free' | 'try_once' | 'monthly' | 'annual'
  action               String // 'start' | 'change' | 'cancel' | 'schedule'
  actionDate           DateTime @default(now())
  effectiveDate        DateTime @default(now())
  stripeSubscriptionId String?
  stripeScheduleId     String?
  metadata             Json     @default("{}")

  user User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  team Team? @relation(fields: [teamId], references: [id])

  @@index([userId, effectiveDate])
  @@index([teamId])
  @@index([planTier])
  @@index([planPeriod])
}

model TeamInvite {
  id                 String              @id @default(cuid())
  email              String
  firstName          String
  teamId             String
  token              String              @unique
  expiresAt          DateTime
  usedAt             DateTime?
  creditsAllocated   Int                 @default(5)
  personId           String?             @unique
  convertedUserId    String?             @unique
  contextId          String?
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  creditTransactions CreditTransaction[]
  team               Team                @relation(fields: [teamId], references: [id], onDelete: Cascade)
  context            Context?            @relation(fields: [contextId], references: [id])
  person             Person?             @relation(fields: [personId], references: [id], onDelete: SetNull)
  convertedUser      User?               @relation(fields: [convertedUserId], references: [id])

  @@index([email])
  @@index([token])
  @@index([expiresAt])
  @@index([teamId])
  @@index([personId])
}

model RefreshToken {
  id        String    @id @default(cuid())
  token     String    @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime  @default(now())
  revokedAt DateTime?
  userAgent String?
  ipAddress String?
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
}

model SecurityLog {
  id        String   @id @default(cuid())
  type      String
  userId    String?
  email     String?
  ipAddress String?
  userAgent String?
  success   Boolean?
  action    String?
  resource  String?
  details   Json?
  createdAt DateTime @default(now())

  @@index([type])
  @@index([userId])
  @@index([createdAt])
  @@index([ipAddress])
}

model UserPackage {
  id          String    @id @default(cuid())
  userId      String
  packageId   String // Folder name where package definition is located (e.g., 'headshot1', 'freepackage')
  purchasedAt DateTime?
  createdAt   DateTime  @default(now())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, packageId])
  @@index([userId])
  @@index([packageId])
}

model RevokedToken {
  id        String   @id @default(cuid())
  jti       String   @unique // JWT ID (jti claim)
  userId    String
  expiresAt DateTime // When the token would naturally expire
  revokedAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([jti])
  @@index([userId])
  @@index([expiresAt])
}

model Feedback {
  id           String      @id @default(cuid())
  personId     String?
  email        String?
  generationId String?
  type         String      // 'general' | 'generation'
  rating       String      // 'up' | 'down'
  comment      String?
  context      String      // 'landing' | 'dashboard' | 'generation'
  options      Json?       // Array of selected feedback reasons
  resolved     Boolean     @default(false)
  resolvedAt   DateTime?
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
  person       Person?     @relation(fields: [personId], references: [id], onDelete: SetNull)
  generation   Generation? @relation(fields: [generationId], references: [id], onDelete: SetNull)

  @@index([personId])
  @@index([generationId])
  @@index([type])
  @@index([rating])
  @@index([resolved])
  @@index([createdAt])
  @@index([context])
}
