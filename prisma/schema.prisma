generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model User {
  id                   String               @id @default(cuid())
  email                String               @unique
  password             String?
  emailVerified        DateTime?
  locale               String               @default("en")
  signupDomain         String? // Domain user signed up from (e.g., "teamshotspro.com", "photoshotspro.com")
  subscriptionStatus   String?
  stripeCustomerId     String?              @unique
  stripeSubscriptionId String?              @unique
  createdAt            DateTime             @default(now())
  updatedAt            DateTime             @updatedAt
  role                 String               @default("user")
  metadata             Json                 @default("{}")
  isAdmin              Boolean              @default(false)
  freeTrialGrantedAt   DateTime?
  planPeriod           String?
  planTier             String?
  tokenVersion         Int                  @default(0) // Incremented when role/permissions change to invalidate all sessions
  accounts             Account[]
  teams                Team[]               @relation("TeamAdmin")
  creditTransactions   CreditTransaction[]
  person               Person?
  refreshTokens        RefreshToken[]
  sessions             Session[]
  convertedFromInvite  TeamInvite?
  transactions         Transaction[]
  subscriptionChanges  SubscriptionChange[]
  userPackages         UserPackage[]
  revokedTokens        RevokedToken[]
  contexts             Context[]
  mobileHandoffTokens  MobileHandoffToken[]
  promoCodeUsages      PromoCodeUsage[]
  extensionTokens      ExtensionToken[]

  @@index([email])
}

model Person {
  id                  String               @id @default(cuid())
  firstName           String
  lastName            String?
  email               String?
  userId              String?              @unique
  teamId              String?
  inviteToken         String?              @unique
  invitedAt           DateTime?
  inviteAcceptedAt    DateTime?
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  onboardingState     String?              @default("not_started") // "not_started", "in_progress", "completed"
  creditTransactions  CreditTransaction[]
  generations         Generation[]
  team                Team?                @relation(fields: [teamId], references: [id])
  user                User?                @relation(fields: [userId], references: [id], onDelete: Cascade)
  selfies             Selfie[]
  teamInvite          TeamInvite?
  feedback            Feedback[]
  assets              Asset[]
  mobileHandoffTokens MobileHandoffToken[]

  @@index([email])
  @@index([teamId])
  @@index([inviteToken])
  @@index([userId])
}

model Team {
  id                   String               @id @default(cuid())
  name                 String?
  website              String?
  domain               String?
  adminId              String
  subscriptionStatus   String?
  stripeCustomerId     String?              @unique
  stripeSubscriptionId String?              @unique
  createdAt            DateTime             @default(now())
  updatedAt            DateTime             @updatedAt
  activeContextId      String?              @unique

  // Seats-based pricing
  totalSeats           Int                  @default(0)
  activeSeats          Int                  @default(0)
  creditsPerSeat       Int                  @default(100)
  isLegacyCredits      Boolean              @default(false)

  activeContext        Context?             @relation("ActiveContext", fields: [activeContextId], references: [id])
  admin                User                 @relation("TeamAdmin", fields: [adminId], references: [id], onDelete: Cascade)
  contexts             Context[]
  creditTransactions   CreditTransaction[]
  teamMembers          Person[]
  teamInvites          TeamInvite[]
  subscriptionChanges  SubscriptionChange[]
  assets               Asset[]

  @@index([adminId])
  @@index([domain])
}

model Context {
  id            String       @id @default(cuid())
  name          String
  teamId        String?
  userId        String?
  packageName   String       @default("headshot1")
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  settings      Json         @default("{}")
  activeForTeam Team?        @relation("ActiveContext")
  team          Team?        @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user          User?        @relation(fields: [userId], references: [id], onDelete: Cascade)
  generations   Generation[]
  teamInvites   TeamInvite[]

  @@index([teamId])
  @@index([userId])
  @@index([packageName])
}

model Generation {
  id                     String    @id @default(cuid())
  creditsUsed            Int       @default(4)
  provider               String    @default("gemini")
  status                 String    @default("processing")
  errorMessage           String?
  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @updatedAt
  acceptedAt             DateTime?
  acceptedPhotoKey       String?
  completedAt            DateTime?
  contextId              String?
  generatedPhotoKeys     String[]
  personId               String
  adminApproved          Boolean   @default(false)
  moderationDate         DateTime?
  moderationPassed       Boolean   @default(false)
  moderationScore        Float?
  userApproved           Boolean   @default(false)
  creditSource           String    @default("individual")
  deleted                Boolean   @default(false)
  deletedAt              DateTime?
  isPublic               Boolean   @default(false)
  maxRegenerations       Int       @default(2)
  remainingRegenerations Int       @default(2)
  generationGroupId      String?
  groupIndex             Int?
  isOriginal             Boolean   @default(true)
  styleSettings          Json?
  outputAssetId          String?   @unique

  // Outfit transfer fields
  generationType     String  @default("headshot") // 'headshot' | 'outfit_transfer'
  outfitReferenceKey String? // S3 key for outfit image (deprecated - use outfitAssetId)
  outfitAssetId      String? // Asset ID for outfit image (preferred)

  context     Context?   @relation(fields: [contextId], references: [id])
  person      Person     @relation(fields: [personId], references: [id], onDelete: Cascade)
  feedback    Feedback[]
  outputAsset Asset?     @relation("GenerationOutput", fields: [outputAssetId], references: [id])
  outfitAsset Asset?     @relation("GenerationOutfit", fields: [outfitAssetId], references: [id])

  @@index([personId])
  @@index([contextId])
  @@index([status])
  @@index([createdAt])
  @@index([isPublic])
  @@index([personId, createdAt])
  @@index([generationType])
  @@index([outfitAssetId])
}

model Selfie {
  id                 String    @id @default(cuid())
  personId           String
  key                String // Legacy S3 key - prefer assetId
  validated          Boolean   @default(false)
  usedInGenerationId String?
  selected           Boolean   @default(false)
  createdAt          DateTime  @default(now())
  fitnessApproved    Boolean   @default(false)
  moderationDate     DateTime?
  moderationPassed   Boolean   @default(false)
  moderationScore    Float?
  userApproved       Boolean   @default(false)
  isPublic           Boolean   @default(false)
  processedKey       String?
  uploadedByUser     String?
  uploadedViaToken   String?
  assetId            String?   @unique
  captureSource      String?   // 'laptop_camera' | 'mobile_camera' | 'file_upload' - how the selfie was captured
  classification     Json?     // All classification data in structured JSON (SelfieClassification type)
  person             Person    @relation(fields: [personId], references: [id], onDelete: Cascade)
  asset              Asset?    @relation("SelfieAsset", fields: [assetId], references: [id])

  @@index([personId])
  @@index([uploadedViaToken])
  @@index([createdAt])
  @@index([isPublic])
  @@index([personId, createdAt])
  @@index([selected])
}

model Transaction {
  id              String   @id @default(cuid())
  userId          String
  type            String
  amount          Float
  creditsDelta    Int
  stripePaymentId String?
  stripeInvoiceId String?
  description     String?
  createdAt       DateTime @default(now())
  creditSource    String?
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([type])
  @@index([createdAt])
}

model WaitlistSignup {
  id        String   @id @default(cuid())
  email     String   @unique
  notified  Boolean  @default(false)
  source    String?
  createdAt DateTime @default(now())

  @@index([email])
  @@index([notified])
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model OTP {
  id        String   @id @default(cuid())
  email     String
  code      String
  expires   DateTime
  verified  Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([email])
  @@index([code])
  @@index([expires])
}

model CreditTransaction {
  id                   String              @id @default(cuid())
  teamId               String?
  personId             String?
  userId               String?
  amount               Float?
  type                 String
  description          String?
  relatedTransactionId String?
  teamInviteId         String?
  createdAt            DateTime            @default(now())
  credits              Int
  currency             String?             @default("USD")
  metadata             Json                @default("{}")
  planPeriod           String?
  planTier             String?
  stripeInvoiceId      String?
  stripePaymentId      String?
  stripeSubscriptionId String?

  // Seats-based pricing fields (optional, only for seat purchases)
  seats                Int?                // Number of seats purchased
  pricePerSeat         Float?              // Price per seat at time of purchase
  stripePriceId        String?             // Stripe price ID used for purchase

  team                 Team?               @relation(fields: [teamId], references: [id], onDelete: Cascade)
  person               Person?             @relation(fields: [personId], references: [id], onDelete: Cascade)
  relatedTransaction   CreditTransaction?  @relation("TransferPair", fields: [relatedTransactionId], references: [id])
  reverseTransactions  CreditTransaction[] @relation("TransferPair")
  teamInvite           TeamInvite?         @relation(fields: [teamInviteId], references: [id])
  user                 User?               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([teamId])
  @@index([personId])
  @@index([userId])
  @@index([type])
  @@index([createdAt])
  @@index([stripePaymentId])
  @@index([stripeSubscriptionId])
  @@index([planTier])
  @@index([seats])
}

model AppSetting {
  key   String @id
  value String
}

model SubscriptionChange {
  id                   String   @id @default(cuid())
  userId               String
  teamId               String?
  planTier             String // 'individual' | 'pro'
  planPeriod           String // 'free' | 'small' | 'large'
  action               String // 'start' | 'change' | 'cancel' | 'schedule'
  actionDate           DateTime @default(now())
  effectiveDate        DateTime @default(now())
  stripeSubscriptionId String?
  stripeScheduleId     String?
  metadata             Json     @default("{}")

  user User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  team Team? @relation(fields: [teamId], references: [id])

  @@index([userId, effectiveDate])
  @@index([teamId])
  @@index([planTier])
  @@index([planPeriod])
}

model TeamInvite {
  id                 String              @id @default(cuid())
  email              String
  firstName          String
  teamId             String
  token              String              @unique
  expiresAt          DateTime
  usedAt             DateTime?
  creditsAllocated   Int                 @default(5)
  personId           String?             @unique
  convertedUserId    String?             @unique
  contextId          String?
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  creditTransactions CreditTransaction[]
  team               Team                @relation(fields: [teamId], references: [id], onDelete: Cascade)
  context            Context?            @relation(fields: [contextId], references: [id])
  person             Person?             @relation(fields: [personId], references: [id], onDelete: SetNull)
  convertedUser      User?               @relation(fields: [convertedUserId], references: [id])

  @@index([email])
  @@index([token])
  @@index([expiresAt])
  @@index([teamId])
  @@index([personId])
}

model RefreshToken {
  id        String    @id @default(cuid())
  token     String    @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime  @default(now())
  revokedAt DateTime?
  userAgent String?
  ipAddress String?
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
}

model SecurityLog {
  id        String   @id @default(cuid())
  type      String
  userId    String?
  email     String?
  ipAddress String?
  userAgent String?
  success   Boolean?
  action    String?
  resource  String?
  details   Json?
  createdAt DateTime @default(now())

  @@index([type])
  @@index([userId])
  @@index([createdAt])
  @@index([ipAddress])
}

model UserPackage {
  id          String    @id @default(cuid())
  userId      String
  packageId   String // Folder name where package definition is located (e.g., 'headshot1', 'freepackage')
  purchasedAt DateTime?
  createdAt   DateTime  @default(now())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, packageId])
  @@index([userId])
  @@index([packageId])
}

model RevokedToken {
  id        String   @id @default(cuid())
  jti       String   @unique // JWT ID (jti claim)
  userId    String
  expiresAt DateTime // When the token would naturally expire
  revokedAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([jti])
  @@index([userId])
  @@index([expiresAt])
}

// MobileHandoffToken: Temporary tokens for QR code mobile selfie upload flow
model MobileHandoffToken {
  id             String   @id @default(cuid())
  token          String   @unique
  userId         String
  personId       String
  expiresAt      DateTime // 15-minute sliding expiration
  absoluteExpiry DateTime // 1-hour maximum lifetime
  createdAt      DateTime @default(now())
  lastUsedAt     DateTime @default(now())
  deviceId       String? // Device identifier after first use (for single-device binding)
  userAgent      String? // For security logging
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  person         Person   @relation(fields: [personId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
  @@index([personId])
  @@index([expiresAt])
}

model Feedback {
  id           String      @id @default(cuid())
  personId     String?
  email        String?
  generationId String?
  type         String // 'general' | 'generation'
  rating       String // 'up' | 'down'
  comment      String?
  context      String // 'landing' | 'dashboard' | 'generation'
  options      Json? // Array of selected feedback reasons
  resolved     Boolean     @default(false)
  resolvedAt   DateTime?
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
  person       Person?     @relation(fields: [personId], references: [id], onDelete: SetNull)
  generation   Generation? @relation(fields: [generationId], references: [id], onDelete: SetNull)

  @@index([personId])
  @@index([generationId])
  @@index([type])
  @@index([rating])
  @@index([resolved])
  @@index([createdAt])
  @@index([context])
}

// Asset: Single source of truth for all files (selfies, logos, backgrounds, intermediates, generated outputs, outfits)
model Asset {
  id       String  @id @default(cuid())
  s3Key    String  @unique
  type     String // 'selfie' | 'logo' | 'background' | 'intermediate' | 'generated' | 'outfit'
  subType  String? // 'person_on_white' | 'background_with_logo' etc.
  mimeType String

  // Ownership
  ownerType String // 'team' | 'person'
  teamId    String?
  personId  String?

  // For reuse (intermediates)
  parentAssetIds   String[]
  styleFingerprint String?
  styleContext     Json?

  // Metadata
  width     Int?
  height    Int?
  sizeBytes Int?
  temporary Boolean   @default(false)
  expiresAt DateTime? // For cleanup job
  metadata  Json? // Additional metadata (e.g., outfit colors, description)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  // Relations
  team             Team?            @relation(fields: [teamId], references: [id], onDelete: Cascade)
  person           Person?          @relation(fields: [personId], references: [id], onDelete: Cascade)
  selfie           Selfie?          @relation("SelfieAsset")
  generationOutput Generation?      @relation("GenerationOutput")
  generationOutfit Generation[]     @relation("GenerationOutfit") // Outfit used in generations
  costs            GenerationCost[] // Costs associated with producing this asset

  @@index([type, subType])
  @@index([styleFingerprint])
  @@index([ownerType, teamId])
  @@index([ownerType, personId])
  @@index([expiresAt])
}

// GenerationCost: Track every AI API call for cost analysis and optimization
model GenerationCost {
  id              String  @id @default(cuid())
  generationId    String?
  personId        String?
  teamId          String?
  provider        String // 'vertex' | 'gemini-rest' | 'replicate'
  model           String // 'gemini-2.5-flash' | 'nano-banana'
  inputTokens     Int?
  outputTokens    Int?
  estimatedCost   Float
  reason          String // 'generation' | 'evaluation' | 'refinement'
  result          String // 'success' | 'failure' (API call result)
  errorMessage    String?
  durationMs      Int?
  workflowVersion String?
  stepName        String?
  outputAssetId   String?
  reusedAssetId   String? // If we reused instead of generating
  costSaved       Float? // Amount saved by reusing

  // NEW: Evaluation outcome tracking
  evaluationStatus  String? // 'approved' | 'rejected' (null for non-evaluation steps)
  rejectionReason   String? // Detailed reason why evaluation rejected the image
  intermediateS3Key String? // S3 key of intermediate/rejected image for review

  createdAt DateTime @default(now())

  // Relations
  outputAsset Asset? @relation(fields: [outputAssetId], references: [id])

  @@index([generationId])
  @@index([personId])
  @@index([teamId])
  @@index([createdAt])
  @@index([evaluationStatus])
}

// PromoCode: Discount codes for marketing campaigns (domain-specific)
model PromoCode {
  id                String           @id @default(cuid())
  code              String           // e.g., "FOUNDING50"
  discountType      String           // "percentage" | "fixed_amount"
  discountValue     Float            // 50 for 50%, or dollar amount
  maxUses           Int?             // null = unlimited
  usedCount         Int              @default(0)
  validFrom         DateTime         @default(now())
  validUntil        DateTime?
  active            Boolean          @default(true)

  // Domain restriction (required)
  domain            String           // "teamshotspro.com" | "photoshotspro.com" | etc.

  // Restrictions
  applicableTo      String[]         @default(["plan", "seats", "top_up"])
  minSeats          Int?             // Minimum seats for seats purchases

  // Stripe sync
  stripeCouponId    String?          @unique
  stripePromoCodeId String?          @unique

  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt

  usages            PromoCodeUsage[]

  @@unique([code, domain]) // Same code can exist on different domains
  @@index([domain])
  @@index([active])
  @@index([code])
}

// PromoCodeUsage: Track each use of a promo code
model PromoCodeUsage {
  id                String     @id @default(cuid())
  promoCodeId       String
  userId            String?
  email             String?    // For guest checkout
  discountAmount    Float      // Actual $ saved
  originalAmount    Float      // Pre-discount amount
  stripeSessionId   String?

  createdAt         DateTime   @default(now())

  promoCode         PromoCode  @relation(fields: [promoCodeId], references: [id], onDelete: Cascade)
  user              User?      @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([promoCodeId])
  @@index([userId])
  @@index([email])
}

// ExtensionToken: Authentication tokens for Chrome extension
model ExtensionToken {
  id         String    @id @default(cuid())
  userId     String
  token      String    @unique // Hashed token (SHA-256)
  name       String?   // User-friendly name, e.g., "Chrome Extension - MacBook Pro"
  scopes     String[]  @default(["outfit:upload", "generation:create"]) // Permissions
  lastUsedAt DateTime?
  lastUsedIp String?
  expiresAt  DateTime
  revokedAt  DateTime?
  createdAt  DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
}

